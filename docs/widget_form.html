<!DOCTYPE html>
<html lang="en">

<head>
	<title>nana::form</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="stylesheet" href="page.css" media="all">
	<link href="fonts/Oswald/Oswald.css" rel="stylesheet">
	<link href="fonts/Arimo/Arimo.css" rel="stylesheet">
	<link href="fonts/OxygenMono/OxygenMono.css" rel="stylesheet">
	<link rel="stylesheet" href="highlight/default.css">
	<script src="highlight/highlight.pack.js"></script>
	<script>hljs.configure({ useBR: true }); hljs.initHighlightingOnLoad();</script>
	<script src="page.js"></script>
</head>

<body>

	<main>

		<section>
			<h1>Class nana::form</h1>
			<p>
				The class <code>nana::form</code> is one of the two widget classes in the <em>root</em> category (the other being <code>nana::nested_form</code>). It is the only widget class that wraps a top-level (non-child) OS native window, and can be used as the main application window, or as a dialog box (modal or non-modal).
			</p>
			<p>
				Like most Nana classes that wrap system resources (such as graphics contexts, fonts, etc), <code>nana::form</code> makes available the native handle of the resource it wraps (OS native window). That means that platform-specific code can be used to manipulate or otherwise interact with the native window (although it is usually not necessary to do so, since the library provides extensive functionality).
			</p>

			<section>
				<h2>Collapsable subsection containing table</h2>
				<table>
					<tr> <th>First column</th> <th>Second column</th> </tr>
					<tr>
						<td>first cell</td>
						<td>second cell</td>
					</tr>
				</table>
			</section>

			<section expanded>
				<h2>Member functions</h2>
				<p>In addition to the methods inherited from <a href="index.html#widget" target="_blank">nana::widget</a> and <a href="index.html#widget_object" target="_blank">nana::widget_object&lt;root_tag, ...&gt;</a>, the class <code>nana::form</code> defines the following methods:</p>

				<table class="functions">
					<tr>
						<td>(constructors)</td>
						<td>construct a <code>nana::form</code> instance</td>
					</tr>
					<tr>
						<td>
							<pre><code>(0)  form(const rectangle& rect = API::make_center(300, 200), const appearance& appear = {});<br>(1)  form(const form& owner, const nana::size& size = { 300, 200 }, const appearance& appear = {});<br>(2)  form(window owner, const nana::size& size = { 300, 200 }, const appearance& appear = {});<br>(3)  form(window owner, const rectangle& rect, const appearance& appear = {});</code></pre>
							<ol>
								<li>default constructor; creates a window owned by the desktop window, with the specified position and dimensions</li>
								<li>copy constructor; does not copy resources from the other form (the other form is only set as the owner window)</li>
								<li>creates a window with the specified owner and dimensions</li>
								<li>creates a window with the specified owner, position, and dimensions</li>
							</ol>
							<p>
								Root window widgets don't have a create method like other <a href="index.html#widget_intro" target="_blank">categories of widgets</a>. When a root window widget is constructed, the window is created immediately, even when the default constructor is used.
							</p>
							<h4>Parameters</h4>
							<table>
								<tr><th>rect</th></tr>
								<tr>
									<td><p>A rectangle indicating the desired position and dimensions for the window. The structure <code>nana::rectangle</code> has the members <code>x</code> and <code>y</code> of type <code>int</code>, and <code>width</code> and <code>height</code> of type <code>unsigned</code>.</p></td>
								</tr>
								<tr><th>owner</th></tr>
								<tr>
									<td><p>The <code>nana::form</code> widget whose window should own this window. An owner window always stays under the window it owns, in the z-order.</p></td>
								</tr>
								<tr><th>size</th></tr>
								<tr>
									<td><p>The desired window size (the window will be centered on the screen). The structure <code>nana::size</code> has the members <code>width</code> and <code>height</code> of type <code>unsigned</code>.</p><p>This parameter controls the size of the <em title="the area of the window that the application draws on">client area</em>. To set the size of the entire window, including the <em title="the elements painted and controlled&#10;by the system (title bar and border)">decorations</em> (nonclient area), call <a href="index.html#api_form::window_outline_size" target="_blank">API::window_outline_size</a>.</p></td>
								</tr>
								<tr><th>appear</th></tr>
								<tr>
									<td><p>The appearance attributes that the window should have, as a <code title="struct appearance&#10;{&#10;	bool taskbar;&#10;	bool floating;&#10;	bool no_activate;&#10;&#10;	bool minimize;&#10;&#9;bool maximize;&#10;&#9;bool sizable;&#10;&#9;bool decoration;&#10;};">nana::appearance</code> structure.</p></td>
								</tr>
							</table>
						</td>
					</tr>
					<tr>
						<td>modality</td>
						<td>shows the form and makes it a modal window</td>
					</tr>
					<tr>
						<td>
							<pre><code>void modality() const;</code></pre>
							<p>
								This method shows the form, and if it has an owner, makes it a modal window (meaning the user can't interact with the owner form until this form is closed).
							</p>
						</td>
					</tr>
					<tr>
						<td>wait_for_this</td>
						<td>blocks execution until the form is closed</td>
					</tr>
					<tr>
						<td>
							<pre><code>void wait_for_this();</code></pre>
							<p>
								This method blocks the calling routine, returning only when the form is closed. Message pumping continues to work, allowing the user to interact with the form.
							</p>
						</td>
					</tr>

					<tr> <th>Layout management</th> </tr>
					<tr>
						<td>function 2</td>
						<td>brief description 2</td>
					</tr>
					<tr>
						<td>
							<pre><code>(0)  void function2(bool param);<br>(1)  bool function2() const;</code></pre>
							<p>
								General description.
							</p>
							<ol>
								<li>brief description of overload</li>
								<li>brief description of overload</li>
							</ol>
							<h4>Parameters</h4>
							<table>
								<tr><th>param</th></tr>
								<tr>
									<td><p>Description of parameter.</p></td>
								</tr>
							</table>
							<h4>Return value</h4>
							<p>Description of return value.</p>
						</td>
					</tr>

				</table>

			</section>

		</section>
	</main>

</body>
</html>