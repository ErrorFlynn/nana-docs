<!DOCTYPE html>
<html lang="en">

<head>
	<title>nana::listbox</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="stylesheet" href="page.css" media="all">
	<link href="fonts/Oswald/Oswald.css" rel="stylesheet">
	<link href="fonts/Arimo/Arimo.css" rel="stylesheet">
	<link href="fonts/OxygenMono/OxygenMono.css" rel="stylesheet">
	<link rel="stylesheet" href="highlight/default.css">
	<script src="highlight/highlight.pack.js"></script>
	<script>hljs.configure({ useBR: true }); hljs.initHighlightingOnLoad();</script>
	<script src="page.js"></script>
</head>

<body>

<main>
	
	<section>
		<h1>Class nana::listbox</h1>
		<p>
			The <code>nana::listbox</code> class provides the functionality of a list box widget that organizes textual data into rows (referred to as "items") and columns. The columns are defined by the listbox header, and are optionally sortable. Rows can be grouped in user-defined categories, otherwise they are placed in a default category.
		</p>
		<p>
			The widget is implemented as a container of categories, which in turn are containers of items. This means that an item is addressed using two "coordinates": a position in the listbox's index of categories, and a position in a category's index of items (the data type <code>index_pair</code> is used for this purpose).
		</p>
		<p>
			The intersection of a column and a row/item is called a <em>cell</em>. By default, the text that is displayed in each cell must be explicitly set by the user, but the listbox also has a mode whereby it displays the contents of an STL sequence container (see <a href="https://github.com/cnjinhao/nana/wiki/Using-STL-Sequence-Container" target="_blank">this article</a> for details).
		</p>

		<img src="img/listbox.png" alt="listbox screenshot">

		<section>
			<h2>Member types</h2>
			<table>
				<tr> <th>Type</th> <th>Description</th> </tr>
				<tr>
					<td>index_pair</td>
					<td>a category position and an item position, acts as an "address" for individual listbox items</td>
				</tr>
				<tr>
					<td>index_pairs</td>
					<td>
						a set of <code>index_pair</code>, a standard container, possibly
						<code>std::vector&#60;index_pair&#62;</code>
					</td>
				</tr>
				<tr>
					<td>size_type</td>
					<td>an integral type, currently equivalent to <code>std::size_t</code> (as of Nana v1.7)</td>
				</tr>
				<tr>
					<td>
						<a href="index.html#cat_proxy" target="_blank">cat_proxy</a>
					</td>
					<td>category iterator and manipulator</td>
				</tr>
				<tr>
					<td><a href="index.html#item_proxy" target="_blank">item_proxy</a></td>
					<td>item iterator and manipulator</td>
				</tr>
				<tr>
					<td>iresolver</td>
					<td>the input resolver that converts an object to an item</td>
				</tr>
				<tr>
					<td>oresolver</td>
					<td>the output resolver that converts an item to an object</td>
				</tr>
				<tr>
					<td>export_options</td>
					<td>the options of exporting items into a string variable</td>
				</tr>
				<tr>
					<td>column_interface</td>
					<td>column operations</td>
				</tr>
			</table>
		</section> <!--member types-->


		<section>
			<h2>Scheme</h2>
			<table>
				<tr> <th>Property</th> <th>Description</th> </tr>
				<tr>
					<td>header_bgcolor</td>
					<td>background color of header columns</td>
				</tr>
				<tr>
					<td>header_fgcolor</td>
					<td>foreground color of header columns</td>
				</tr>
				<tr>
					<td>header_grabbed</td>
					<td>background color of grabbed header column</td>
				</tr>
				<tr>
					<td>header_floated</td>
					<td>background of header column when it is grabbed and moved</td>
				</tr>
				<tr>
					<td>item_selected</td>
					<td>background color of item when it is selected</td>
				</tr>
				<tr>
					<td>item_highlighted</td>
					<td>background color of item when it is highlighted</td>
				</tr>
				<tr>
					<td>selection_box</td>
					<td>the color of selection box</td>
				</tr>
				<tr>
					<td>max_fit_content</td>
					<td>
						the max column width which is generated by fit_content is allowed, in pixels. It is ignored
						when it is 0, or a non-zero value is passed to fit_content()
					</td>
				</tr>
				<tr>
					<td>min_column_width</td>
					<td>the minimum width of column, excluding the suspension_width</td>
				</tr>
				<tr>
					<td>text_margin</td>
					<td>
						left/right margin to the text to determine the cell width. Width of cell = text_margin * 2 +
						text width + 1
					</td>
				</tr>
				<tr>
					<td>header_height</td>
					<td>height of header, in pixels</td>
				</tr>
				<tr>
					<td>text_height (deprecated)</td>
					<td>text height of item, in pixels. It will be set by the listbox with current font</td>
				</tr>
				<tr>
					<td>item_height_ex</td>
					<td>extra height of item, in pixels</td>
				</tr>
				<tr>
					<td>item_height</td>
					<td>the minimum width of column, excluding the suspension_width</td>
				</tr>
				<tr>
					<td>header_splitter_area_before</td>
					<td>response area before header splitter</td>
				</tr>
				<tr>
					<td>header_splitter_area_after</td>
					<td>response area after header splitter</td>
				</tr>
				<tr>
					<td>mouse_wheel</td>
					<td>the number of lines/characters to scroll when vertical/horziontal mouse wheel is moved</td>
				</tr>
			</table>
		</section> <!--scheme-->

		<section>
			<h2>Events</h2>
			<p>
				In addition to the <a href="http://nanapro.org/en-us/documentation/core/events.htm">general events</a>
				that most widgets have, the listbox also has the following:
			</p>
			<table>
				<tr> <th>Event</th> <th>Description</th> </tr>
				<tr>
					<td>checked(const arg_listbox&)</td>
					<td>occurs when an item is checked or unchecked</td>
				</tr>
				<tr>
					<td>selected(const arg_listbox&)</td>
					<td>occurs when an item is selected or unselected</td>
				</tr>
				<tr>
					<td>category_dbl_click(const arg_listbox_category&)</td>
					<td>occurs when a category is double clicked</td>
				</tr>
			</table>
		</section> <!--events-->

		<section expanded>
			<h2>Member functions</h2>

			<table class="functions">
				<tr>
					<td>(constructors)</td>
					<td>construct a <code>nana::listbox</code> instance</td>
				</tr>
				<tr>
					<td>
						<pre><code>(0)  listbox();<br />(1)  listbox(window handle, bool visible);<br />(2)  listbox(window handle, const rectangle& ={}, bool visible = true);</code></pre>
						<h3>(0) empty object constructor (default constructor)</h3>
						<p>
							Constructs an "empty" <code>listbox</code> object. Does not create a UI element;
							<code>listbox.create(...)</code> must be subsequently called before the object can be used
							as a widget.
						</p>
						<h3>(1, 2) create constructors</h3>
						<p>
							Construct and initialize a <code>listbox</code> object, making it usable as a widget.
						</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>handle</th></tr>
							<tr>
								<td><p>A handle to a parent widget, which is usually a <code>nana::form</code> or a <code>nana::panel</code>. Keep in mind that all widgets have a <a href="https://en.cppreference.com/w/cpp/language/cast_operator" target="_blank">conversion operator</a> that returns a <code>nana::window</code>, so you can pass a widget object directly to these constructors, instead of having to call <code>handle()</code> on the widget object.</p></td>
							</tr>
							<tr><th>visible</th></tr>
							<tr>
								<td>
									<p>
										A boolean flag that specifies the visibility of the listbox after it is created.
									</p>
								</td>
							</tr>
						</table>
					</td>
				</tr>

				<tr> <th>Associative category access</th> </tr>
				<tr>
					<td>assoc (Nana 1.4)</td>
					<td>access specified category</td>
				</tr>
				<tr>
					<td>
						<pre><code>template &#60;typename Key&#62; cat_proxy assoc(Key&& key);</code></pre>
						<p>
							This method returns the category that is mapped to the specified key; it inserts a new category if such key does not exist. Iterators are invalidated if an insertion is performed. Relevant article: <a href="https://github.com/cnjinhao/nana/wiki/Listbox-Associative-Category" target="_blank">Listbox Associative Category</a>.
						</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>key</th></tr>
							<tr>
								<td><p>the key of the category to return</p></td>
							</tr>
						</table>
						<h4>Return value</h4>
						<p>
							An iterator to the category associated with the key.
						</p>
					</td>
				</tr>

				<tr>
					<td>assoc_at (Nana 1.4)</td>
					<td>access specified category with bounds checking</td>
				</tr>
				<tr>
					<td>
						<pre><code>template&#60;typename Key&#62; cat_proxy assoc_at(Key&& key);<br />template&#60;typename Key&#62; const cat_proxy assoc_at(Key&& key) const;</code></pre>
						<p>
							Returns the category that is associated with the specified key. Bounds checking is performed, exception of type <code>std::out_of_range</code> will be thrown if the key does not exist. Relevant article: <a href="https://github.com/cnjinhao/nana/wiki/Listbox-Associative-Category" target="_blank">Listbox Associative Category</a>.
						</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>key</th></tr>
							<tr>
								<td><p>the key of the category to return</p></td>
							</tr>
						</table>
						<h4>Return value</h4>
						<p>
							An iterator to the category associated with the key.
						</p>
						<h4>Exception</h4>
						<p><code>std::out_of_range</code> if the key doesn't exist.</p>
					</td>
				</tr>

				<tr>
					<td>assoc_erase (Nana 1.4)</td>
					<td>erases a category</td>
				</tr>
				<tr>
					<td>
						<pre><code>template&#60;typename Key&#62; void assoc_erase(Key&& key);</code></pre>
						<p>
							Removes a category that is associated with the specified key. If the key does not exist, no category will be removed. Relevant article: <a href="https://github.com/cnjinhao/nana/wiki/Listbox-Associative-Category" target="_blank">Listbox Associative Category</a>.
						</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>key</th></tr>
							<tr>
								<td><p>a key object indicating a category to remove</p></td>
							</tr>
						</table>
					</td>
				</tr>

				<tr>
					<td>assoc_ordered (Nana 1.4)</td>
					<td>enables or disables the ordered insertion of categories</td>
				</tr>
				<tr>
					<td>
						<pre><code>bool assoc_ordered(bool enable);</code></pre>
						<p>
							Enables or disables the ordered insertion of categories (does not affect the order of existing categories). Ordered insertion only works if all the keys associated with categories have the same type. Relevant article: <a href="https://github.com/cnjinhao/nana/wiki/Listbox-Associative-Category" target="_blank">Listbox Associative Category</a>.
						</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>enable</th></tr>
							<tr>
								<td><p><code>true</code> to enable ordered insertion, or <code>false</code> to disable it</p></td>
							</tr>
						</table>
						<h4>Return value</h4>
						<p>
							<code>true</code> if the mode switch succeeded, or <code>false</code> otherwise
						</p>
					</td>
				</tr>

				<tr> <th>Column access</th> </tr>
				<tr>
					<td>column_at (Nana 1.5)</td>
					<td>access a specified column with bounds-checking</td>
				</tr>
				<tr>
					<td>
						<pre><code>column_interface& column_at(size_type pos, bool disp_order = false);<br>const column_interface& column_at(size_type pos, bool disp_order = false) const;</code></pre>
						<p>
							Returns a reference to the column at the specified position. Bounds checking is performed.
						</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>pos</th></tr>
							<tr>
								<td><p>the position of the column to access</p></td>
							</tr>
							<tr><th>disp_order</th></tr>
							<tr>
								<td>
									<p>
										Indicates whether <code>pos</code> is a display position (the position at which a column is displayed after reordering) or an absolute position (the position that a column had at creation). If this
										parameter is <code>true</code>, <code>pos</code> represents a display position. If the parameter is
										<code>false</code>, <code>pos</code> represents an absolute position.
									</p>
								</td>
							</tr>
						</table>
						<h4>Return value</h4>
						<p>a reference to the column at the requested position</p>
						<h4>Exception</h4>
						<p><code>std::out_of_range</code> if !(pos < column_size())</p>
					</td>
				</tr>

				<tr>
					<td>column_from_pos</td>
					<td>returns the position of column by a specified point</td>
				</tr>
				<tr>
					<td>
						<pre><code>size_type column_from_pos(const point & pos) const;</code></pre>
						<p>
							Returns the absolute position of the column which contains the specified point.
						</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>pos</th></tr>
							<tr>
								<td><p>the point to be checked</p></td>
							</tr>
						</table>
						<h4>Return value</h4>
						<p>The absolute position of the column (the position that the column had at creation), or <code>nana::npos</code> on failure.</p>
					</td>
				</tr>

				<tr>
					<td>column_movable (Nana 1.7)</td>
					<td>allows or disallows the repositioning of columns by the user</td>
				</tr>
				<tr>
					<td>
						<pre><code>(0)  void column_movable(bool movable);<br>(1)  bool column_movable() const;</code></pre>
						<p>
							When columns are movable, the user can drag them into new positions (that is the default state).
						</p>
						<ol>
							<li>allows or disallows the moving of columns</li>
							<li>determines whether columns are movable</li>
						</ol>
						<h4>Parameters</h4>
						<table>
							<tr><th>movable</th></tr>
							<tr>
								<td><p>Indicates whether to allow columns to be moved. If this parameter is <code>false</code>, the user will not be able to drag columns into new positions (although they can still be repositioned programmatically, by calling <a href="index.html#widget_listbox::reorder_columns" target="_blank">listbox::reorder_columns</a>).</p></td>
							</tr>
						</table>
						<h4>Return value</h4>
						<p>(1) <code>true</code> if columns can be moved, or <code>false</code> otherwise.</p>
					</td>
				</tr>

				<tr>
					<td>column_resizable (Nana 1.7)</td>
					<td>enables / disables the resizability of the column</td>
				</tr>
				<tr>
					<td>
						<pre><code>void column_resizable(bool resizable);<br>bool column_resizable() const;</code></pre>
						<p>
							When a column is not resizable, it doesn't show a west-east cursor when the user moves
							the cursor to the gap between two columns, and the column can't be resized by dragging
							the gap.
						</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>resizable</th></tr>
							<tr>
								<td><p>Indicates whether the column can be resized.</p></td>
							</tr>
						</table>
						<h4>Return value</h4>
						<p><code>true</code> if the column can be resized, or <code>false</code> otherwise.</p>
					</td>
				</tr>

				<tr>
					<td>column_size</td>
					<td>returns the number of columns</td>
				</tr>
				<tr>
					<td>
						<pre><code>size_type column_size() const;</code></pre>
						<p>Returns the number of columns that the listbox has.</p>
						<h4>Return value</h4>
						<p>The number of columns.</p>
					</td>
				</tr>

				<tr>
					<td>move_column (Nana 1.7)</td>
					<td>moves a column to a new position</td>
				</tr>
				<tr>
					<td>
						<pre><code>void move_column(size_type abs_pos, size_type view_pos);</code></pre>
						<p>
							Moves a column to a new display position. If <code>abs_pos</code> or <code>view_pos</code> is out of range, this function does nothing.
						</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>abs_pos</th></tr>
							<tr>
								<td><p>The absolute position of the column (the position it had at creation).</p></td>
							</tr>
							<tr><th>view_pos</th></tr>
							<tr>
								<td><p>The position where the column should be displayed.</p></td>
							</tr>
						</table>
					</td>
				</tr>

				<tr>
					<td>reorder_columns (Nana 1.7)</td>
					<td>repositions columns according to a sort order</td>
				</tr>
				<tr>
					<td>
						<pre><code>void reorder_columns(size_type first_col,<br>						size_type last_col,<br>						index_pair row, bool reverse,<br>						std::function&#60;bool(const std::string &cell1, size_type col1,<br>										const std::string &cell2, size_type col2,<br>										const nana::any *rowval,<br>										bool reverse)&#62; comp);</code></pre>
						<p>
							This function reorders the columns in the range [first_col, last_col], using a row. More specifically, it sorts the group of cells at the intersection of the column range and the row, and repositions the columns in accordance with the new order of the cells.
						</p>
						<p>
							Repositioning the columns does not affect the order they have in the internal column container (which is the order they were added in). The columns are simply <em>displayed</em> in a new order, which creates the dichotomy between <em>display positions</em> and <em>absolute positions</em>. That is why <a href="index.html#widget_listbox::column_at" target="_blank">listbox::column_at</a> has the <code>disp_order</code> parameter.
						</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>first_col</th></tr>
							<tr>
								<td><p>the absolute position of the first column</p></td>
							</tr>
							<tr><th>last_col</th></tr>
							<tr>
								<td><p>the absolute position of the last column</p></td>
							</tr>
							<tr><th>row</th></tr>
							<tr>
								<td><p>the index of a row which is used for comparing</p></td>
							</tr>
							<tr><th>reverse</th></tr>
							<tr>
								<td><p>indicates whether the sort order is to be reversed or not</p></td>
							</tr>
							<tr><th>comp</th></tr>
							<tr>
								<td>
									<p>
										A <a href="https://en.wikipedia.org/wiki/Weak_ordering" target="_blank">weak ordering</a>
										comparer function. Here's an example of what it could look like:
									</p>
									<pre><code>using size_type = nana::listbox::size_type;<br>auto comparer = [](const std::string &cell1, size_type col1, <br>					const std::string &cell2, size_type col2, <br>					const nana::any *rowval, bool reverse)<br>{<br>	return reverse ? cell1 &#62; cell2 : cell1 &#60; cell2;<br>};</code></pre>
								</td>
							</tr>
						</table>
					</td>
				</tr>

				<tr><th>Element access</th></tr>
				<tr><td>at</td><td>access an item or category with bounds checking</td></tr>
				<tr>
					<td>
						<pre><code>(0)  cat_proxy at(size_type pos);<br>(1)  const cat_proxy at(size_type pos) const;<br><br>(2)  item_proxy at(const index_pair& abs_pos);<br>(3)  const item_proxy at(const index_pair &abs_pos) const;</code></pre>
						<p>Returns an iterator to the content at specified location <code>pos</code>. Bounds checking is performed, exception of type <code>std::out_of_range</code> will be thrown on invalid access.</p>
						<h3>(0, 1) access a category</h3>
						<div>
							<h4>Parameter</h4>
							<table>
								<tr><th>pos</th></tr>
								<tr>
									<td><p>index of the category to access</p></td>
								</tr>
							</table>
							<h4>Return value</h4>
							<p>an iterator to the requested category</p>
						</div>
						<h3>(2, 3) access an item</h3>
						<div>
							<h4>Parameter</h4>
							<table>
								<tr><th>abs_pos</th></tr>
								<tr>
									<td><p>The absolute position of the item to access. "Absolute position" means the position that the item had at creation, as opposed to the position it is displayed at after sorting (for details, see the <em>"Remarks"</em> section of <a href="index.html#widget_listbox::sort_col" target="_blank">listbox::sort_col</a>).</p></td>
								</tr>
							</table>
							<h4>Return value</h4>
							<p>an iterator to the requested item</p>
						</div>
					</td>
				</tr>

				<tr><td>operator[] (Nana 1.4)</td><td>access an item or category without bounds checking</td></tr>
				<tr>
					<td>
						<pre><code>(0)  cat_proxy operator[](size_type pos);<br>(1)  const cat_proxy operator[](size_type pos) const;<br><br>(2)  item_proxy operator[](const index_pair& abs_pos);<br>(3)  const item_proxy operator[](const index_pair &abs_pos) const;</code></pre>
						<p>Returns an iterator to the content at specified location <code>pos</code>. No bounds checking is performed, therefore the behavior is undefined if location <code>pos</code> is invalid.</p>
						<h3>(0, 1) access a category</h3>
						<div>
							<h4>Parameter</h4>
							<table>
								<tr><th>pos</th></tr>
								<tr>
									<td><p>index of the category to access</p></td>
								</tr>
							</table>
							<h4>Return value</h4>
							<p>an iterator to the requested category</p>
						</div>
						<h3>(2, 3) access an item</h3>
						<div>
							<h4>Parameter</h4>
							<table>
								<tr><th>abs_pos</th></tr>
								<tr>
									<td><p>The absolute position of the item to access. "Absolute position" means the position that the item had at creation, as opposed to the position it is displayed at after sorting (for details, see the <em>"Remarks"</em> section of <a href="index.html#widget_listbox::sort_col" target="_blank">listbox::sort_col</a>).</p></td>
								</tr>
							</table>
							<h4>Return value</h4>
							<p>an iterator to the requested item</p>
						</div>
					</td>
				</tr>

				<tr><th>Observers</th></tr>
				<tr><td>checked</td><td>returns the set of all checked items</td></tr>
				<tr>
					<td>
						<pre><code>index_pairs checked() const;</code></pre>
						<p>Returns a sequence container with the locations of all checked items. A checked item is an item whose associated checkbox is checked (see <a href="index.html#widget_listbox::checkable" target="_blank">listbox::checkable</a>).</p>
						<h4>Return value</h4>
						<p>An std container that contains a set of <code>index_pair</code> objects which indicate the checked items (using their absolute positions within categories). As of Nana v1.7, <code>index_pairs</code> is an alias for <code>std::vector&#60;index_pair&#62;</code>.</p>
					</td>
				</tr>

				<tr><td>selected</td><td>returns the set of all selected items</td></tr>
				<tr>
					<td>
						<pre><code>index_pairs selected() const;</code></pre>
						<p>Returns a sequence container with the locations of all selected items.</p>
						<h4>Return value</h4>
						<p>An std container that contains a set of <code>index_pair</code> objects which point to the selected items. As of Nana v1.7, <code>index_pairs</code> is an alias for <code>std::vector&#60;index_pair&#62;</code>.</p>
					</td>
				</tr>

				<tr><td>size_categ</td><td>returns the number of categories</td></tr>
				<tr>
					<td>
						<pre><code>size_type size_categ() const;</code></pre>
						<p>This method returns the number of categories, which is always at least 1 due to the default category (which cannot be removed).</p>
						<h4>Return value</h4>
						<p>The number of categories, as an integral type. As of Nana v1.7, <code>listbox::size_type</code> is an alias for <code>std::size_t</code>.</p>
					</td>
				</tr>

				<tr><td>size_item</td><td>returns the number of items in a category</td></tr>
				<tr>
					<td>
						<pre><code>size_type size_item(size_type cat) const;</code></pre>
						<p>This method returns the number of items contained by the specified category.</p>
						<h4>Return value</h4>
						<p>The number of items, as an integral type. As of Nana v1.7, <code>listbox::size_type</code> is an alias for <code>std::size_t</code>.</p>
					</td>
				</tr>

				<tr><td>visible_header</td><td>determines the visibility of the listbox header</td></tr>
				<tr>
					<td>
						<pre><code>bool visible_header() const;</code></pre>
						<p>Determines the visibility of the listbox header.</p>
						<h4>Return value</h4>
						<p><code>true</code> if the header is visible, or <code>false</code> otherwise</p>
					</td>
				</tr>

				<tr><th>Operations</th></tr>
				<tr><td>append_header</td><td>appends a new column</td></tr>
				<tr>
					<td>
						<pre><code>(0)  size_type append_header(std::string text, unsigned width = 120);<br>(1)  size_type append_header(std::wstring text, unsigned width = 120);</code></pre>
						<p>Appends a new column at the end.</p>

						<h4>Parameters</h4>
						<table>
							<tr><th>text</th></tr>
							<tr>
								<td><p>The title of the new column. Only a UTF-8 encoded string is accepted for <code>std::string</code> overloading.</p></td>
							</tr>
							<tr><th>width</th></tr>
							<tr>
								<td><p>The width of column, in pixels.</p></td>
							</tr>
						</table>
						<h4>Return value</h4>
						<p>the index of the new column</p>
					</td>
				</tr>

				<tr><td>auto_draw</td><td>enables/disables automatic drawing</td></tr>
				<tr>
					<td>
						<pre><code>void auto_draw(bool enable);</code></pre>
						<p>This function enables or disables automatic drawing. If auto drawing is disabled, the listbox no longer automatically redraws when its contents changes. This is useful to avoid inefficiency and save CPU time when performing many operations in a row, like when appending a large number of items, for example.</p><p>In such a case, the listbox redrawing each time an item is appended is redundant and needlessly slows down operation. To prevent that, you would typically first disable auto drawing, then append the items, and finally re-enable auto drawing.</p>

						<h4>Parameters</h4>
						<table>
							<tr><th>enable</th></tr>
							<tr>
								<td><p>indicates whether to enable or disable auto drawing</p></td>
							</tr>
						</table>
					</td>
				</tr>

				<tr><td>avoid_drawing (Nana 1.4)</td><td>temporarily suspends automatic drawing and executes a function</td></tr>
				<tr>
					<td>
						<pre><code>template&#60typename Function&#62 void avoid_drawing(Function fn);</code></pre>
						<p>This is a simple helper function that disables automatic drawing before calling a user function, and then re-enables automatic drawing when the user function returns. Implementation as of Nana v1.7:</p>
						<pre><code>template&#60;typename Function&#62;<br>void avoid_drawing(Function fn)<br>{<br>	this-&#62;auto_draw(false);<br>	try<br>	{<br>		fn();<br>	}<br>	catch (...)<br>	{<br>		this-&#62;auto_draw(true);<br>		throw;<br>	}<br>	this-&#62;auto_draw(true);<br>}</code></pre>

						<h4>Parameters</h4>
						<table>
							<tr><th>fn</th></tr>
							<tr>
								<td><p>the function to call</p></td>
							</tr>
						</table>
					</td>
				</tr>

				<tr><td>cast</td><td>returns the item or category that is being displayed at the specified pixel coordinates</td></tr>
				<tr>
					<td>
						<pre><code>index_pair cast( const point& pos ) const</code></pre>
						<p>This method tests whether the specified point falls within the draw area of an item or category currently being displayed in the listbox viewport.</p>

						<h4>Parameters</h4>
						<table>
							<tr><th>pos</th></tr>
							<tr>
								<td><p>The listbox viewport coordinates to test (coordinates {0, 0} represent the upper-left corner of the listbox's draw area).</p></td>
							</tr>
						</table>
						<h4>Return value</h4>
						<div><p>An <code>index_pair</code> object representing an item or a category, or an empty object if the coordinates don't "hit" an item or a category.</p><p>The object is "empty" when both <code>index_pair::item</code> and <code>index_pair::cat</code> have the value <code>nana::npos</code>. To easily test whether the object is empty, call <code>index_pair::empty()</code>.</p><p>If the returned object represents an item, a <em>display position</em> is used to identify the item. See the <em>"Remarks"</em> section of <a href="index.html#widget_listbox::sort_col" target="_blank">listbox::sort_col</a> for an explanation of the difference between a <em>display postition</em> and an <em>absolute position</em>.</p></div>
					</td>
				</tr>

				<tr><td>category_icon (Nana 1.5.4)</td><td>modifies the category icon</td></tr>
				<tr>
					<td>
						<pre><code>(0)  listbox& category_icon(std::function&#60;void(paint::graphics& graph, const rectangle& rt_icon, bool expanded)&#62; icon_renderer);<br><br>(1)  listbox& category_icon(const paint::image& img_expanded, const paint::image& img_collapsed);</code></pre>
						<ol>
							<li>Sets a renderer function for the category icon.</li>
							<li>Sets new images for the category icon.</li>
						</ol>
						<h4>Parameters</h4>
						<table>
							<tr><th>icon_renderer</th></tr>
							<tr>
								<td><p>a renderer function</p></td>
							</tr>
							<tr><th>img_expanded</th></tr>
							<tr>
								<td><p>an image that is shown when the category is expanded</p></td>
							</tr>
							<tr><th>img_collapsed</th></tr>
							<tr>
								<td><p>an image that is shown when the category is collapsed</p></td>
							</tr>
						</table>
						<h4>Return value</h4>
						<p>The reference of <code>*this</code>.</p>
					</td>
				</tr>

				<tr><td>checkable</td><td>enables/disables a mode whereby each item (row) has a checkbox</td></tr>
				<tr>
					<td>
						<pre><code>void checkable(bool enable);</code></pre>
						<p>This function enables or disables the "checkable" mode of the listbox. When this mode is enabled, each item displays a checkbox in the leftmost column, to the left of the cell text.</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>enable</th></tr>
							<tr>
								<td><p>indicates whether to enable or disable checkable mode</p></td>
							</tr>
						</table>
					</td>
				</tr>

				<tr><td>enable_single / disable_single</td><td>enables/disables single selection/check</td></tr>
				<tr>
					<td>
						<pre><code>void enable_single(bool for_selection, bool category_limited);<br>void disable_single(bool for_selection);</code></pre>
						<p>Sets whether the user can check or select multiple items at the same time.</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>for_selection</th></tr>
							<tr>
								<td><p>indicates whether the operation applies to selecting (<code>true</code>) or to checking (<code>false</code>)</p></td>
							</tr>
							<tr><th>category_limited</th></tr>
							<tr>
								<td><p>Indicates whether the single selecting/checking applies to the whole listbox, or to each category individually.</p><p>If single selecting/checking is enabled and this parameter is <code>true</code>, then a single item can be checked or selected in each category (meaning that multiple items can be checked/selected across multiple categories).</p><p>If this parameter is <code>false</code>, then only one item can be checked/selected in the entire listbox.</p></td>
							</tr>
						</table>
					</td>
				</tr>

				<tr><td>hovered (Nana 1.7)</td><td>returns the hovered item</td></tr>
				<tr>
					<td>
						<pre><code>index_pair hovered(bool return_end) const;</code></pre>
						<p>Returns the position of the item that the mouse cursor is hovering over. If there is no such item, the function returns either an empty <code>index_pair</code> object, or an end position (depending on the value of parameter <code>return_end</code>).</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>return_end</th></tr>
							<tr>
								<td><p>If <code>true</code>, causes the function to return an end position instead of an empty object if no item is hovered.</p></td>
							</tr>
						</table>
						<h4>Return value</h4>
						<p>An <code>index_pair</code> object that indicates the <em>display position</em> of the hovered item. If no item is hovered and  <code>return_end</code> is <code>true</code>, the position returned is that of the last item in the last category. See the <em>"Remarks"</em> section of <a href="index.html#widget_listbox::sort_col" target="_blank">listbox::sort_col</a> for an explanation of the difference between a <em>display postition</em> and an <em>absolute position</em>.</p>
						<h4>Remarks</h4>
						<div>
							<p>
								If the parameter <code>return_end</code> is <code>false</code>, you can test if the returned object is empty by calling <code>index_pair::empty()</code>:
								<pre><code>if(list_box.hovered(false).empty())<br>{<br>	//No item is hovered.<br>}</code></pre>
							</p>
							<p>Having the function return an end position can be useful if you're trying to insert items at the position of the hovered item (you might do that as part of a drag-drop operation using <code>nana::simple_dragdrop</code>). If the user wants to insert the items at the end of the list, it's possible that they could hover the mouse cursor over the empty space after the last item (assuming the listbox even contains any items). In that case, it's useful that the function returns an end position instead of an empty <code>index_pair</code> object:</p>
							<pre><code>// Inserts into `list2` all the items that are selected in `list1`, at the position of the hovered item.<br>// If there is no hovered item, the selected items are appended to `list2`.<br>list2.insert_item(list2.hovered(true), list1, list1.selected());</code></pre>
						</div>

					</td>
				</tr>

				<tr><td>is_single_enabled (Nana 1.7)</td><td>determines whether single selection/check is enabled</td></tr>
				<tr>
					<td>
						<pre><code>bool is_single_enabled(bool for_selection) const noexcept;</code></pre>
						<p>Determines whether single selection/check is enabled.</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>for_selection</th></tr>
							<tr>
								<td><p>indicates whether the operation applies to selecting (<code>true</code>) or to checking (<code>false</code>)</p></td>
							</tr>
						</table>
						<h4>Return value</h4>
						<p><code>true</code> if single selection/check is enabled, or <code>false</code> otherwise</p>
					</td>
				</tr>

				<tr><td>move_select</td><td>moves the selection cursor to a position adjacent to its current one</td></tr>
				<tr>
					<td>
						<pre><code>void move_select(bool upwards);</code></pre>
						<p>This method moves the selection cursor one position upwards or downwards, depending on the argument passed to it.</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>upwards</th></tr>
							<tr>
								<td><p>indicates the direction of movement</p></td>
							</tr>
						</table>
					</td>
				</tr>

				<tr><td>scroll (Nana 1.2)</td><td>scrolls the view to the bottom/top</td></tr>
				<tr>
					<td>
						<pre><code>void scroll(bool to_bottom, size_type cat_pos = ::nana::npos);<br>void scroll(bool to_bottom, const index_pair& abs_pos);</code></pre>
						<p>Scrolls a category or an item into view, aligning it to the bottom/top.</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>to_bottom</th></tr>
							<tr>
								<td><p>indicates whether to scroll the view to the bottom (<code>true</code>) or the top (<code>false</code>)</p></td>
							</tr>
							<tr><th>cat_pos</th></tr>
							<tr>
								<td><p>the index of a category to scroll into view; if it is <code>nana::npos</code>, scrolls to the last category</p></td>
							</tr>
							<tr><th>pos</th></tr>
							<tr>
								<td><p>specifies an item to scroll into view</p></td>
							</tr>
						</table>
					</td>
				</tr>

				<tr><td>show_header</td><td>shows/hides the listbox header</td></tr>
				<tr>
					<td>
						<pre><code>void show_header(bool show);</code></pre>
						<p>Shows/hides the listbox column header.</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>show</th></tr>
							<tr>
								<td><p>indicates whether to show or hide the listbox column header</p></td>
							</tr>
						</table>
					</td>
				</tr>

				<tr><td>set_deselect (Nana 1.7.2)</td><td>sets a deselection predicate</td></tr>
				<tr>
					<td>
						<pre><code>void set_deselect(std::function&#60;bool(nana::mouse)&#62; predicate);</code></pre>
						<p>
							Sets a predicate function that determines whether items should be deselected when <code>mouse_up</code> is triggered.
							The predicate is only called when the listbox would normally deselect the selected items during the <code>mouse_up</code> event (for example when the user clicks a selected item without holding down a modifier key). In all other situations, the predicate isn't called (for example when the user performs a box selection, because the listbox doesn't deselect the items during that operation).
						</p>
						<p>In practice, this function is only called when multiple items are selected, and the user either clicks one of the selected items, or clicks on empty space. This is because when an unselected item is clicked, the selected items are deselected during the <code>mouse_down</code> event.</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>predicate</th></tr>
							<tr>
								<td><p>A function that returns <code>true</code> if the deselection of items should be allowed, or <code>false</code> if it should be suppressed. The <code>nana::mouse</code> parameter indicates which mouse button was released to trigger the <code>mouse_up</code> event.</p></td>
							</tr>
						</table>
						<h4>Example</h4>
						<div>
							<p>The following example shows how the predicate could be used to suppress the deselection of items when the user right-clicks on a selected item. This would be needed when implementing a pop-up menu for the listbox, with commands that target the selected items.</p>
							<pre><code>list_box.set_deselect([&](nana::mouse btn) {<br>	return !(btn == nana::mouse::right_button && !list_box.hovered(false).empty());<br>});</code></pre>
						</div>
					</td>
				</tr>

				<tr><th>Modifiers</th></tr>
				<tr><td>append</td><td>appends new categories to the listbox</td></tr>
				<tr>
					<td>
						<pre><code>cat_proxy append(std::string category);<br>void append(std::initializer_list&#60;std::string&#62; categories);</code></pre>
						<p>Appends new categories to the listbox.</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>category</th></tr>
							<tr>
								<td><p>the name of the new category</p></td>
							</tr>
							<tr><th>categories</th></tr>
							<tr>
								<td><p>the names of the new categories, specified by initializer list</p></td>
							</tr>
						</table>
						<h4>Return value</h4>
						<p>an iterator to the new category</p>
					</td>
				</tr>

				<tr><td>clear</td><td>removes all the items from one or all categories</td></tr>
				<tr>
					<td>
						<pre><code>(0)  void clear(size_type pos);<br>(1)  void clear();</code></pre>
						<h3>(0) clear a specific category</h3>
						<p>Removes all the items from the specified category (the category itself is not removed).</p>
						<h3>(1) clear all categories</h3>
						<p>Removes all the items from all categories, including the default category. The categories themselves are not removed.</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>pos</th></tr>
							<tr>
								<td><p>the index position of the category whose items should be cleared</p></td>
							</tr>
						</table>
						<h4>Exception</h4>
						<p><code>std::out_of_range</code> if <code>pos</code> is not less than the number of categories</p>
					</td>
				</tr>

				<tr><td>erase</td><td>removes categories or items</td></tr>
				<tr>
					<td>
						<pre><code>(0)  void erase(size_type pos);<br>(1)  void erase();<br>(2)  void erase(index_pairs indexes);<br>(3)  item_proxy erase(item_proxy item);</code></pre>
						<p>Removes categories (including any contained items), or specific items. The default category (at index 0) is never removed, being cleared of items instead.</p>
						<ol>
							<li>Removes a specific category.</li>
							<li>Removes all categories, effectively emptying the listbox.</li>
							<li>Removes a set of items. This is faster than repeatedly calling (3) if there are many items to be deleted.</li>
							<li>Removes a single item.</li>
						</ol>
						<h4>Parameters</h4>
						<table>
							<tr><th>pos</th></tr>
							<tr>
								<td><p>the index position of a category to be removed</p></td>
							</tr>
							<tr><th>indexes</th></tr>
							<tr>
								<td><p>a set of index pairs identifying the items to be removed</p></td>
							</tr>
							<tr><th>item</th></tr>
							<tr>
								<td><p>an iterator pointing to an item to be removed</p></td>
							</tr>
						</table>
						<h4>Return value</h4>
						<p>(3) returns an iterator to the item that follows the removed item</p>
						<h4>Exception</h4>
						<p><code>std::out_of_range</code> if <code>pos</code> is not less than the number of categories</p>
					</td>
				</tr>

				<tr><td>insert</td><td>inserts a new category at an arbitrary position</td></tr>
				<tr>
					<td>
						<pre><code>cat_proxy insert(cat_proxy pos, std::string text);<br>cat_proxy insert(cat_proxy pos, std::wstring text);</code></pre>
						<p>Inserts a new category before <code>pos</code>.</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>pos</th></tr>
							<tr>
								<td><p>a category iterator representing the position before which the new category will be inserted</p></td>
							</tr>
							<tr><th>text</th></tr>
							<tr>
								<td><p>the name of the new category (<code>std::string</code> is for UTF-8 encoded text)</p></td>
							</tr>
						</table>
						<h4>Return value</h4>
						<p>a category iterator pointing to the newly inserted category</p>
						<h4>Exception</h4>
						<p><code>std::out_of_range</code> if <code>pos</code> is invalid</p>
					</td>
				</tr>

				<tr><td>insert_item</td><td>inserts a new item, or a set of items</td></tr>
				<tr>
					<td>
						<pre><code>(0)  void insert_item(const index_pair& abs_pos, std::string text);<br>(1)  void insert_item(const index_pair& abs_pos, const std::wstring& text);<br>(2)  void insert_item(index_pair abs_pos, const listbox& rhs, const index_pairs& indexes);</code></pre>
						<p>(0, 1) Inserts a new item before an absolute position.<br>(2) Copies items from an existing listbox.</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>abs_pos</th></tr>
							<tr>
								<td><p>the absolute position before which the item will be inserted</p></td>
							</tr>
							<tr><th>text</th></tr>
							<tr>
								<td><p>the text for the first cell of the new item (<code>std::string</code> is for UTF-8 encoded text)</p></td>
							</tr>
							<tr><th>rhs</th></tr>
							<tr>
								<td><p>another listbox which provides items to be copied</p></td>
							</tr>
							<tr><th>indexes</th></tr>
							<tr>
								<td><p>a set of index pairs identifying the items to be copied</p></td>
							</tr>
						</table>
						<h4>Exception</h4>
						<p><code>std::out_of_range</code> if <code>abs_pos</code> is invalid</p>
					</td>
				</tr>

				<tr><th>Ordering</th></tr>
				<tr><td>sortable</td><td>enables/disables the sorting of items by a column</td></tr>
				<tr>
					<td>
						<pre><code>(0)  bool sortable() const;<br>(1)  void sortable(bool enable);</code></pre>
						<p>When a listbox is sortable, users can click a column header to sort the items by that column.</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>enable</th></tr>
							<tr>
								<td><p>indicates whether to enable or disable the sort</p></td>
							</tr>
						</table>
						<h4>Return value</h4>
						<p>(0) <code>true</code> if the listbox is sortable, or <code>false</code> otherwise</p>
					</td>
				</tr>

				<tr><td>freeze_sort</td><td>temporarily prevents automatic sorting</td></tr>
				<tr>
					<td>
						<pre><code>bool freeze_sort(bool freeze);</code></pre>
						<p>Sets a flag to prevent automatic sorting. Freezing the sorting before many insertion operations (for example) avoids redundant sorting for each insertion operation.</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>freeze</th></tr>
							<tr>
								<td><p>indicates whether to freeze or unfreeze the automatic sorting of items</p></td>
							</tr>
						</table>
						<h4>Return value</h4>
						<p>the previous automatic sorting status (<code>true</code> if sorting was frozen before calling this function, or <code>false</code> otherwise)</p>
					</td>
				</tr>

				<tr><td>set_sort_compare</td><td>sets a strict weak ordering comparer for item sorting</td></tr>
				<tr>
					<td>
						<pre><code>void set_sort_compare(	size_type col,<br>						std::function&#60;bool(const std::string&, nana::any*,<br>								            const std::string&, nana::any*, bool reverse)&#62; compare);</code></pre>
						<p>Sets a custom <a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">strict weak ordering</a> comparer function to be used when sorting the items by a specific column.</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>col</th></tr>
							<tr>
								<td><p>The index of the column for which the custom comparer function should be used. The same comparer can be set for multiple columns. The listbox will continue to use the default comparer when the items are sorted by  columns which haven't had a custom comparer set.</p></td>
							</tr>
							<tr><th>compare</th></tr>
							<tr>
								<td><p>A comparer function that meets the requirements of strict weak ordering: irreflexivity (<code>compare(x, x)</code> returns <code>false</code>) and antisymmetry (<code>compare(a, b) != compare(b, a)</code> is <code>true</code>).</p></td>
							</tr>
						</table>
						<h4>Examples of comparer functions</h4>
						<div>
							<p>This function compares items using the cell text:</p>
							<pre><code>bool compare(const std::string& text_l, nana::any*, const std::string& text_r, nana::any*, bool reverse)<br>{<br>	return (reverse ? text_l &#62; text_r : text_l &#60; text_r);<br>}<br></code></pre>
							<p>This function compares items using the custom data associated with them:</p>
							<pre><code>bool compare(const std::string&, nana::any* any_l, const std::string&, nana::any* any_r, bool reverse)<br>{<br>	if(any_l && any_r) 	// some items may not have any associated custom data<br>	{<br>		int * il = nana::any_cast&#60;int&#62;(any_l);<br>		int * ir = nana::any_cast&#60;int&#62;(any_r);<br>		return (il && ir && (reverse ? *il &#62; *ir : *il &#60; *ir));<br> 		// ^ some types may not be int<br>	}<br>	return false;<br>}<br><br>auto cat = listbox.at(0);<br>cat.at(0).value(10); // 10 is custom data<br>cat.at(1).value(20); // 20 is custom data</code></pre>
						</div>
					</td>
				</tr>

				<tr><td>sort_col</td><td>sets the sort column, sorts all items, and enables automatic sorting</td></tr>
				<tr>
					<td>
						<pre><code>(0)  void sort_col(size_type col, bool reverse = false);<br>(1)  size_type sort_col() const;</code></pre>
						<p>(0) Sorts all items by the specified column, and enables automatic sorting for subsequent item changes. Automatic sorting causes the items to be automatically re-sorted whenever there's a relevant change to the listbox contents. As a side-effect, this method potentially invalidates any stored display positions that were obtained before the items got sorted (see the "remarks" section below).</p>
						<p>Calling this method is equivalent to the user clicking on a column header when the listbox is sortable, except that the listbox window doesn't immediately redraw to reflect any changes (for that, you should call <code>nana::API::refresh_window</code> with the listbox object as an argument).</p>
						<p>(1) Returns the current sort column.</p>
						<h4>Parameters</h4>
						<table>
							<tr><th>col</th></tr>
							<tr>
								<td><p>The index of the column to set as the sort column. If this parameter is <code>nana::npos</code>, automatic sorting is cancelled.</p></td>
							</tr>
							<tr><th>reverse</th></tr>
							<tr>
								<td><p>Indicates whether to reverse the sort order.</p></td>
							</tr>
						</table>
						<h4>Return value</h4>
						<p>(1) The index of the current sort column, or <code>nana::npos</code> if no sort column has been set.</p>
						<h4>Remarks</h4>
						<div>
							<p>It is important to understand that a listbox category doesn't actually reorder its internal item container when the items are sorted. Instead, each category maintains an index of display positions for the sorted order. When sorting is enabled, the listbox simply <em>displays</em> the items in the sorted order, while continuing to address them using their absolute (unsorted) positions assigned to them at creation.</p>
							<p>This can result in a mismatch between the display position and the absolute position of an item, when the items are sorted. This is important, because all methods that take an <code>index_pair</code> argument expect an absolute position, while some methods (like <a href="index.html#widget_listbox::hovered" target="_blank">listbox::hovered</a>) return a display position. To resolve this issue, the <a href="index.html#cat_proxy::index_cast" target="_blank">cat_proxy::index_cast</a> method should be used to convert one type of position into the other.</p>
						</div>
					</td>
				</tr>

				<tr><td>unsort</td><td>cancels automatic sorting</td></tr>
				<tr>
					<td>
						<pre><code>void unsort();</code></pre>
						<p>Cancels automatic sorting. As a side effect, this method potentially invalidates any stored display positions that were obtained when the items were sorted.</p>
						<p>A possible implementation:</p>
						<pre><code>void unsort()<br>{<br>	this-&#62;sort_col(nana::npos, false);<br>}</code></pre>
					</td>
				</tr>

				<tr><th>Visible range</th></tr>
				<tr><td>first_visible (Nana 1.7)</td><td>returns the first visible element</td></tr>
				<tr>
					<td>
						<pre><code>index_pair first_visible() const;</code></pre>
						<p>Returns the index of the first visible item or category. To test whether the returned <code>index_pair</code> represents a category or an item, call <code>index_pair::is_category()</code>. If the listbox doesn't have any items, the returned object is empty (test by calling <code>index_pair::empty()</code>).</p>
						<h4>Return value</h4>
						<p>The display position of first visible element (for an explanation of the term <em>"display position"</em>, see the "Remarks" section of <a href="index.html#widget_listbox::sort_col" target="_blank">listbox::sort_col</a>).</p>
					</td>
				</tr>

				<tr><td>last_visible (Nana 1.7)</td><td>returns the last visible element</td></tr>
				<tr>
					<td>
						<pre><code>index_pair last_visible() const;</code></pre>
						<p>Returns the index of the last visible item or category. To test whether the returned <code>index_pair</code> represents a category or an item, call <code>index_pair::is_category()</code>. If the listbox doesn't have any items, the returned object is empty (test by calling <code>index_pair::empty()</code>).</p>
						<h4>Return value</h4>
						<p>the index of last visible element</p>
					</td>
				</tr>

				<tr><td>visibles (Nana 1.7)</td><td>returns all visible items</td></tr>
				<tr>
					<td>
						<pre><code>index_pairs visibles() const;</code></pre>
						<p>Returns a set of all the items that are currently displayed in the listbox viewport.</p>
						<h4>Return value</h4>
						<p>an <code>index_pairs</code> container with all the visible items</p>
					</td>
				</tr>

			</table>


		</section> <!--member functions-->

	</section>
		
	<section>
		<h1>Usage details and functionality</h1>
		<p>This section discusses usage details, and tries to explain the major features and functionality of the widget.</p>
		
		<section>
			<h2>Adding items and accessing cells</h2>
			<p>
				As mentioned in the introduction to the class, the listbox widget is a container of categories, and each category is a container of items. Every item that is added to the listbox must belong to a category. If it's not desired to have any "visible" categories (which have a name and can be clicked on), then the items must be added to the default category, which has the position 0 in the category index.
			</p>
			<p>But before any items can be added, first a column must be added to the listbox:</p>
			<pre><code>list_box.append_header("Column 0");</code></pre>
			<p>The listbox is created without columns, and will throw an <code>std::out_of_range</code> exception if items are added without a column present.</p>
			<hr />

			<p>In order to add an item to a category, a <a href="index.html#cat_proxy" target="_blank">cat_proxy</a> category iterator must be obtained:</p>
			<pre><code>nana::listbox::cat_proxy cat0 {list_box.at(0)}; // get iterator pointing to category 0</code></pre>
			<p>Then, <code>cat_proxy::append</code> can be used to add a new item to the category:</p>
			<pre><code>cat0.append("cell 0 of item 0");</code></pre>
			<p>For the sake of clarity, the code above stores the category iterator into a variable before using it. If a variable is not necessary, the code can be contracted into one line :</p>
			<pre><code>list_box.at(0).append("cell 0 of item 0"); // append new item to category 0</code></pre>
			<hr />

			<p>The code discussed so far produces a listbox with one item (row), which has one cell. In order to read the text in that cell, first an item iterator must be obtained by calling <code>cat_proxy::at</code>:</p>
			<pre><code>nana::listbox::item_proxy ip {list_box.at(0).at(0)}; // get iterator pointing to item 0 of category 0</code></pre>
			<p>Then, the cell text can be obtained by calling <code>item_proxy::text</code>:</p>
			<pre><code>std::cout &#60;&#60; ip.text(0) &#60;&#60; std::endl; // get the text of cell 0</code></pre>
			<p>The two lines above can be contracted into one:</p>
			<pre><code>// get the text from (category 0)->(item 0)->(cell 0)<br>std::cout &#60;&#60; list_box.at(0).at(0).text(0) &#60;&#60; std::endl;</code></pre>
			<hr />

			<p>Of course, a listbox can have more than one column, and consequently items can have more than one cell. When an item with multiple cells is added, an initializer list can be used to pass the cell strings to <code>cat_proxy::append</code>:</p>
			<pre><code>list_box.append_header("Column 1");<br>list_box.at(0).append({"cell 0 of item 1", "cell 1 of item 1"});</code></pre>
			<p>The code so far has added two columns, but the first item that was added earlier still only has text for its first cell. If an attempt is made to retrieve the text of its second cell, an <code>std::out_of_range</code> exception will be thrown (internally, the item is missing the second cell entirely). The missing text should be set:</p>
			<pre><code>list_box.at(0).at(0).text(1, "cell 1 of item 0");</code></pre>
			<p>Adding a second column didn't automatically add a second cell to the first item. Attempting to set the text for the second second cell forced the library to create the cell.</p>
			<hr />

			<p>The <a href="index.html#item_proxy" target="_blank">item_proxy</a> class has member functions that let the user change most item properties. The code above set the text of a cell, but it's also possible to set the background <a href="index.html#color" target="_blank">color</a> of an item, for example.</p>
			<pre><code>// change the background color of the second item<br>list_box.at(0).at(1).bgcolor(nana::colors::light_salmon);</code></pre>
			<p>Changing the colors of a single cell rather than the whole item is a bit more complicated, but possible:</p>
			<pre><code>// change the bg color of the second cell of the first item<br>nana::color cellbg {"#bbeebb"}; // green bg color<br>nana::color cellfg {list_box.at(0).at(0).fgcolor()}; // keep the same foreground<br>std::string cellstr {list_box.at(0).at(0).text(1)}; // copy the existing text<br>nana::listbox::cell cell {cellstr, {cellbg, cellfg}}; // construct a new cell<br>list_box.at(0).at(0).text(1, cell); // set the new cell using item_proxy::text</code></pre>
			<hr />

			<p>Finally, here are the code fragments that were discussed above, coalesced into a compilable example:</p>
			<pre><code>#include &#60;nana/gui.hpp&#62;<br>#include &#60;nana/gui/widgets/listbox.hpp&#62;<br>#include &#60;iostream&#62;<br><br>int main()<br>{<br>	nana::form fm;<br>	fm.div("vert margin=15 &#60;lb&#62;");<br><br>	nana::listbox list_box {fm};<br>	fm["lb"] &#60;&#60; list_box;<br>	list_box.append_header("Column 0");<br>	list_box.at(0).append("cell 0 of item 0"); // append new item to category 0<br><br>	// get the text from (category 0)-&#62;(item 0)-&#62;(cell 0)<br>	std::cout &#60;&#60; list_box.at(0).at(0).text(0) &#60;&#60; std::endl;<br><br>	list_box.append_header("Column 1");<br>	list_box.at(0).append({"cell 0 of item 1", "cell 1 of item 1"});<br>	list_box.at(0).at(0).text(1, "cell 1 of item 0");<br><br>	// change the background color of the second item<br>	list_box.at(0).at(1).bgcolor(nana::colors::light_salmon);<br><br>	// change the bg color of the second cell of the first item<br>	nana::color cellbg {"#bbeebb"}; // green bg color<br>	nana::color cellfg {list_box.at(0).at(0).fgcolor()}; // keep the same foreground<br>	std::string cellstr {list_box.at(0).at(0).text(1)}; // copy the existing text<br>	nana::listbox::cell cell {cellstr, {cellbg, cellfg}}; // construct a new cell<br>	list_box.at(0).at(0).text(1, cell); // set the new cell using item_proxy::text<br><br>	fm.collocate();<br>	fm.show();<br>	nana::exec();<br>}</code></pre>
		</section>

        <section expanded>
			<h2>Accessing the selected items</h2>
			<p>
				The previous section showed how to access arbitrary items, but what about accessing the set of currently selected items? The listbox makes that very easy, by providing the <a href="index.html#widget_listbox::selected" target="_blank">selected</a> method. This method returns a sequence container with the "addresses" of all selected items.
			</p>
			<p>
                Such an "address" is an <code>index_pair</code> object, which represents a pair of positions that locates the item (a position in the listbox's index of categories, and a position in a category's index of items). An <code>index_pair</code> object can be passed to <a href="index.html#widget_listbox::at" target="_blank">listbox::at</a> to access the item it identifies.
			</p>
			<p>
                Since <a href="index.html#widget_listbox::selected" target="_blank">listbox::selected</a> returns a sequence container, it's very easy to iterate through it using a range-based <code>for</code> loop. This is illustrated in the following example, which changes the color of all selected items when a button is pressed:
			</p>
            <pre><code>#include &#60;nana/gui.hpp&#62;<br>#include &#60;nana/gui/widgets/button.hpp&#62;<br>#include &#60;nana/gui/widgets/listbox.hpp&#62;<br>#include &#60;random&#62;<br><br>int main()<br>{<br>&#9;nana::form fm {nana::API::make_center(300, 420)};<br>&#9;fm.div("vert margin=15 &#60;listbox&#62;&#60;weight=15&#62;&#60;button weight=30&#62;");<br><br>&#9;nana::listbox list_box {fm};<br>&#9;fm["listbox"] &#60;&#60; list_box;<br><br>&#9;// add two columns and three categories<br>&#9;list_box.append_header("column zero");<br>&#9;list_box.append_header("column one");<br>&#9;list_box.append({"category one", "category two", "category three"});<br><br>&#9;// add three items to each category<br>&#9;for(unsigned cat_count = 0; cat_count &#60; list_box.size_categ(); cat_count++)<br>&#9;{<br>&#9;&#9;for(unsigned item_count = 0; item_count &#60; 3; item_count++)<br>&#9;&#9;{<br>&#9;&#9;&#9;auto str {"item " + std::to_string(item_count)};<br>&#9;&#9;&#9;list_box.at(cat_count).append({str + " cell zero", str + " cell one"});<br>&#9;&#9;}<br>&#9;}<br><br>&#9;nana::button btn {fm, "Change the color of selected items"};<br>&#9;fm["button"] &#60;&#60; btn;<br><br>&#9;btn.events().click([&]<br>&#9;{<br>&#9;&#9;// generate a random color to apply to each selected item<br>&#9;&#9;std::mt19937 eng {std::random_device {}()};<br>&#9;&#9;std::uniform_int_distribution&#60;unsigned&#62; distr {0, 0xffffff};<br>&#9;&#9;nana::color_rgb clr {distr(eng)};<br><br>&#9;&#9;// iterate though all selected items using a range-based for loop<br>&#9;&#9;for(const auto &cat_item : list_box.selected()) // `cat_item` is of type listbox::index_pair<br>&#9;&#9;&#9;list_box.at(cat_item).fgcolor(clr); // change the color of each selected item<br>&#9;});<br><br>&#9;fm.collocate();<br>&#9;fm.show();<br>&#9;nana::exec();<br>}</code></pre>
		</section>

	</section>
</main>

</body>
</html>